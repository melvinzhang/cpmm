module CPMM

  use mach.int.UInt32GMP
  use mach.int.UInt64GMP
  use option.Option

  type cpmm = {
    e: UInt32GMP.uint32;
    t: UInt32GMP.uint32; 
    l: UInt32GMP.uint32;
  }

  type liquidity_result = {
    delta_t: UInt32GMP.uint32;
    delta_l: UInt32GMP.uint32;
  }

  let constant fee_numerator = (997: UInt32GMP.uint32)
  let constant fee_denominator = (1000: UInt32GMP.uint32)

  let create (ether_reserve: UInt32GMP.uint32) (token_reserve: UInt32GMP.uint32) (initial_liquidity: UInt32GMP.uint32) : cpmm =
    { e = ether_reserve; t = token_reserve; l = initial_liquidity }

  let k (pool: cpmm) : UInt64GMP.uint64 =
    UInt64GMP.of_uint32 pool.e * UInt64GMP.of_uint32 pool.t

  let get_input_price (delta_x: UInt32GMP.uint32) (x_reserve: UInt32GMP.uint32) (y_reserve: UInt32GMP.uint32) : option UInt32GMP.uint32 =
    let u64_delta_x = UInt64GMP.of_uint32 delta_x in
    let u64_x = UInt64GMP.of_uint32 x_reserve in
    let u64_y = UInt64GMP.of_uint32 y_reserve in
    let u64_fee_num = UInt64GMP.of_uint32 fee_numerator in
    let u64_fee_den = UInt64GMP.of_uint32 fee_denominator in
    
    let numerator = u64_fee_num * u64_delta_x * u64_y in
    let denominator = u64_fee_den * u64_x + u64_fee_num * u64_delta_x in
    
    if denominator = 0 then
      None
    else
      Some (UInt64GMP.to_uint32 (numerator / denominator))

  let get_output_price (delta_y: UInt32GMP.uint32) (x_reserve: UInt32GMP.uint32) (y_reserve: UInt32GMP.uint32) : option UInt32GMP.uint32 =
    if delta_y >= y_reserve then
      None
    else
      let u64_delta_y = UInt64GMP.of_uint32 delta_y in
      let u64_x = UInt64GMP.of_uint32 x_reserve in
      let u64_y = UInt64GMP.of_uint32 y_reserve in
      let u64_fee_num = UInt64GMP.of_uint32 fee_numerator in
      let u64_fee_den = UInt64GMP.of_uint32 fee_denominator in
      
      let numerator = u64_fee_den * u64_x * u64_delta_y in
      let denominator = u64_fee_num * (u64_y - u64_delta_y) in
      
      if denominator = 0 then
        None
      else
        Some (UInt64GMP.to_uint32 (numerator / denominator) + 1)

  let eth_to_token (pool: cpmm) (delta_e: UInt32GMP.uint32) : option (UInt32GMP.uint32, cpmm) =
    match get_input_price delta_e pool.e pool.t with
    | None -> None
    | Some delta_t ->
        let new_pool = { e = pool.e + delta_e; t = pool.t - delta_t; l = pool.l } in
        Some (delta_t, new_pool)
    end

  let token_to_eth (pool: cpmm) (delta_t: UInt32GMP.uint32) : option (UInt32GMP.uint32, cpmm) =
    match get_input_price delta_t pool.t pool.e with
    | None -> None
    | Some delta_e ->
        let new_pool = { e = pool.e - delta_e; t = pool.t + delta_t; l = pool.l } in
        Some (delta_e, new_pool)
    end

  let eth_to_token_exact (pool: cpmm) (delta_t: UInt32GMP.uint32) : option (UInt32GMP.uint32, cpmm) =
    match get_output_price delta_t pool.e pool.t with
    | None -> None
    | Some delta_e ->
        let new_pool = { e = pool.e + delta_e; t = pool.t - delta_t; l = pool.l } in
        Some (delta_e, new_pool)
    end

  let token_to_eth_exact (pool: cpmm) (delta_e: UInt32GMP.uint32) : option (UInt32GMP.uint32, cpmm) =
    match get_output_price delta_e pool.t pool.e with
    | None -> None
    | Some delta_t ->
        let new_pool = { e = pool.e - delta_e; t = pool.t + delta_t; l = pool.l } in
        Some (delta_t, new_pool)
    end

  let add_liquidity (pool: cpmm) (delta_e: UInt32GMP.uint32) : option (liquidity_result, cpmm) =
    if pool.e = 0 || pool.t = 0 then
      None
    else
      let u64_delta_e = UInt64GMP.of_uint32 delta_e in
      let u64_t = UInt64GMP.of_uint32 pool.t in
      let u64_e = UInt64GMP.of_uint32 pool.e in
      let u64_l = UInt64GMP.of_uint32 pool.l in
      
      let delta_t_calc = u64_delta_e * u64_t / u64_e + 1 in
      let delta_l_calc = u64_delta_e * u64_l / u64_e in
      
      let delta_t = UInt64GMP.to_uint32 delta_t_calc in
      let delta_l = UInt64GMP.to_uint32 delta_l_calc in
      
      let new_pool = { e = pool.e + delta_e; t = pool.t + delta_t; l = pool.l + delta_l } in
      let result = { delta_t = delta_t; delta_l = delta_l } in
      
      Some (result, new_pool)

  type removal_result = {
    removed_e: UInt32GMP.uint32;
    removed_t: UInt32GMP.uint32;
  }

  let remove_liquidity (pool: cpmm) (delta_l: UInt32GMP.uint32) : option (removal_result, cpmm) =
    if delta_l > pool.l then
      None
    else
      let u64_delta_l = UInt64GMP.of_uint32 delta_l in
      let u64_e = UInt64GMP.of_uint32 pool.e in
      let u64_t = UInt64GMP.of_uint32 pool.t in
      let u64_l = UInt64GMP.of_uint32 pool.l in
      
      let delta_e_calc = u64_delta_l * u64_e / u64_l in
      let delta_t_calc = u64_delta_l * u64_t / u64_l in
      
      let delta_e = UInt64GMP.to_uint32 delta_e_calc in
      let delta_t = UInt64GMP.to_uint32 delta_t_calc in
      
      let new_pool = { e = pool.e - delta_e; t = pool.t - delta_t; l = pool.l - delta_l } in
      let result = { removed_e = delta_e; removed_t = delta_t } in
      
      Some (result, new_pool)

end
